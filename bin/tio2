#!/usr/bin/env node
/**
 * tio2 will run tests written as normal mocha specs in a Titanium app.
 * these tests then are run on device or simulator and collected and sent back to the CLI.
 *
 * See LICENSE for information and copyright.
 */
var colors = require('colors'),
	program = require('commander'),
	path = require('path'),
	fs = require('fs-extra'),
	UglifyJS = require('uglify-js'),
	async = require('async'),
	tiapp = require('tiapp.xml'),
	minimatch = require('minimatch'),
	wrench = require('wrench'),
	ioslib = require('ioslib'),
	androidlib = require('androidlib'),
	spawn = require('child_process').spawn,
	exec = require('child_process').exec,
	log = require('../lib/log'),
	pkg = JSON.parse(fs.readFileSync(path.join(__dirname,'../package.json')).toString());

program
  .version(pkg.version)
  .usage('[options] <directory>')
  .option('-q, --quiet', 'no build logging')
  .option('-p, --platform [name]', 'platform such as ios, android, etc')
  .option('-c, --count [count]', 'number of iterations to sample for each test case')
  .option('-g, --grep [expr]', 'run regular expression on each test to filter specific tests to execute')
  .option('-t, --target [target]', 'target either device or simulator (default)')
  .option('-l, --log-level [level]','set the log-level for logging. defaults to info')
  .option('-r, --recursive','include sub directories')
  .parse(process.argv);


if (program.args.length!==1) {
	program.help();
}

// turn grep into a regular expression
program.grep = program.grep && new RegExp(program.grep);
log.level = program.logLevel || 'info';

if (program.quiet) {
	log.level = 'quiet';
}

function die() {
	log.fatal.apply(log.fatal,arguments);
}

// make sure the project directory passed in is valid
var project_dir = path.resolve(program.args[0]),
	source_tiapp = path.join(project_dir, 'tiapp.xml');

if (!fs.existsSync(project_dir)) {
	die("Couldn't find project at",project_dir);
}

// make sure this is a Ti project
if (!fs.existsSync(source_tiapp)) {
	die("Doesn't look like a Titanium project. Couldn't find ",source_tiapp);
}

// load up our tiapp.xml
source_tiapp = tiapp.load(source_tiapp);

var alloy = false;

// check if app is Alloy app
var plugins = source_tiapp.getPlugins();

// iterate through a list of plugins from the tiapp.xml
plugins.forEach(function(plugin) {
	if(plugin.id == 'ti.alloy')
		alloy = true;
});

if(alloy) {
	// Execute Alloy build process
	var args = [
		'compile',
		project_dir,
		'--config',
		'platform=' + program.platform
	];

	var child = spawn('alloy', args);
	child.stdout.on('data', function (data) {
		console.log('' + data);
	});

	child.stderr.on('data', function (data) {
		console.log('' + data);
	});

	child.on('close',function(exitCode){
		if (exitCode!==0) {
			console.log("alloy build exited with exitCode "+exitCode);
		}
		else {
			executeRestOfBuildProcess();
		}
	});
}
else {
	executeRestOfBuildProcess();
}

function executeRestOfBuildProcess() {
	// create a temp build directory and let OS natively clean up as needed
	var build_dir = path.join(require('os').tmpdir(),'tio2_'+source_tiapp.name);

	if (!fs.existsSync(build_dir)) {
		fs.mkdir(build_dir);
	}

	// copy the project into our build directory
	wrench.copyDirSyncRecursive(project_dir, build_dir,{
		forceDelete:true
	});

	// make sure this is a valid Titanium project
	var resource_dir = path.join(build_dir,'Resources'),
		tiapp_xml = path.join(build_dir,'tiapp.xml');

	if (!fs.existsSync(resource_dir)) {
		die("Couldn't find Titanium Resources directory at",resource_dir);
	}

	if (!fs.existsSync(tiapp_xml)) {
		die("Couldn't find Titanium configuration file at",tiapp_xml);
	}

	// we are going to inject these modules into generated source
	var timocha = path.join(__dirname,'..','node_modules','ti-mocha','ti-mocha.js'),
		should = path.join(__dirname,'..','node_modules','should','should.js');

	if (!fs.existsSync(timocha)) {
		die("Couldn't find ti-mocha at",timocha);
	}

	if (!fs.existsSync(should)) {
		die("Couldn't find should at",should);
	}

	// loook for our specs folder in our project
	var specs = path.join(project_dir,'specs');

	if (!fs.existsSync(specs)) {
		die("Couldn't find specs folder at",specs);
	}

	var EXCLUDE_DIRS = ['.DS_Store','.git','.svn','CVS','RCS','SCCS'];

	/**
	 * returns true if file path is a directory
	 */
	function isDirectory(file) {
		return fs.statSync(file).isDirectory();
	}

	/**
	 * Recursively get a listing of files for a given directory
	 */
	function filelisting(recursive, dir, filter, files, dest) {
		files = files || [];
		var type = typeof(filter);
		fs.readdirSync(dir).forEach(function(f) {
			if (f === dest) {
				return;
			}
			f = path.join(path.resolve(dir), f);
			var base = path.basename(f);
			if (isDirectory(f)) {
				recursive && !~EXCLUDE_DIRS.indexOf(f) && filelisting(recursive, f, filter, files, dest);
			}
			else {
				if (filter) {
					if (type === 'function') {
						filter(f,dir) && files.push(f);
					}
					else if (type === 'object') {
						filter.test(f) && files.push(f);
					}
				}
				else {
					files.push(f);
				}
			}
		});
		return files;
	}

	// copy non-JS files
	var nonjsfiles = filelisting(program.recursive,specs,function(f){return !/\.js$/.test(f)});
	nonjsfiles.forEach(function(f){
		var relative = path.relative(specs,f),
			dest = path.join(resource_dir, relative),
			destdir = path.dirname(dest);
		if (fs.existsSync(destdir)) {
			wrench.mkdirSyncRecursive(destdir);
		}
		fs.copySync(f, dest);
	});


	// re-check to see if tiapp.xml was in the specs folder
	var dest_tiapp = path.join(resource_dir, 'tiapp.xml');
	if (fs.existsSync(dest_tiapp)) {
		// copy over our tiapp
		fs.copySync(dest_tiapp, tiapp_xml);
		// remove from resources
		fs.unlinkSync(dest_tiapp);
	}

	// load up our tiapp.xml
	tiapp = tiapp.load(tiapp_xml);

	// Make sure new tiapp.xml does not execute Alloy build process
	if(alloy)
		tiapp.removePlugin('ti.alloy');

	var version = tiapp.sdkVersion,
		platform = program.platform,

		targets = tiapp.getDeploymentTargets(),
		target_names = Object.keys(targets),
		found;

	// check our deployment targets for this project with the platform under test
	for (var c=0;c<target_names.length;c++) {
		var target = target_names[c],
			enabled = targets[target];

		if (platform===target && !enabled) {
			die("tiapp.xml is not configured to support the platform '"+platform+"'");
		}
		if (!platform && /(ipad|iphone|ios)/.test(target) && /darwin/.test(process.platform)) {
			platform = found = 'iphone';
			break;
		}
		if (platform===target || (/(iphone|ipad|ios)/.test(platform) && /(iphone|ipad|ios)/.test(target))) {
			found = true;
			break;
		}
	}

	if (!platform || !found) {
		die("Could not determine the platform. Specify with --platform");
	}

	// defaults by platform
	var defaultTargets = {
		android: 'emulator',
		iphone: 'simulator',
		ios: 'simulator',
		ipad: 'simulator'
	};

	// resolve the correct default target based on platform
	program.target = program.target || defaultTargets[platform];

	var platform_ios = /(iphone|ipad|ios)/i.test(platform),
		platform_android = /(android)/i.test(platform),
		// files we're going to shuffle
		dest_timocha = path.join(resource_dir,'ti-mocha.js'),
		dest_should = path.join(resource_dir,'should.js'),
		module_dest;

	// Check for existence of platform-specific app.js
	if (fs.existsSync( path.join(resource_dir,platform,'app.js')))
		 dest_appjs = path.join(resource_dir,platform,'app.js');
	else
		 dest_appjs = path.join(resource_dir,'app.js');

	fs.copySync(timocha, dest_timocha);
	fs.copySync(should, dest_should);


	// make sure we write out our module info
	if (platform_ios) {
		tiapp.setModule('com.appcelerator.timer', '1.0', 'iphone');
		var ios_module = path.join(__dirname,'..','modules','ios','com.appcelerator.timer-iphone-1.0.zip'),
			ios_module_dest = module_dest = path.join(build_dir, path.basename(ios_module));

		fs.copySync(ios_module,ios_module_dest);
	}
	else if (platform_android) {
		tiapp.setModule('com.appcelerator.timer', '1.0', 'android');
		var android_module = path.join(__dirname,'..','modules','android','com.appcelerator.timer-android-1.0.zip'),
			android_module_dest = module_dest = path.join(build_dir, path.basename(android_module));

		fs.copySync(android_module,android_module_dest);
	}

	// save our tiapp.xml
	tiapp.write();

	var resultsRegex = /\!TEST_RESULTS_START\!/,
		resultsEndRegex = /\!TEST_RESULTS_STOP\!/,
		inResults,
		results = [];

	/**
	 * run a build and launch the test
	 */
	function runTest (callback) {

		var args = [
			'--build-only',
			'--platform',
			platform,
			'--project-dir',
			build_dir,
			'--sdk',
			version,
			'--no-colors',
			'--no-progress-bars',
			'--no-banner',
			'--no-prompt',
			'--target',
			program.target,
			'build'
		],
		testResult,
		_finished,
		targetlib;

		function finish() {
			if (!_finished) {
				_finished=true;
				var args=arguments;
				process.nextTick(function(){
					targetlib && targetlib[program.target].stop();
					callback.apply(callback,args);
				});
			}
		}

		function logger(label, message) {
			if (platform_ios && /^Assertion failed: \(AMDeviceTransferApplication/.test(message)) {
				return;
			}
			if (resultsRegex.test(message)) {
				inResults = true;
			}
			else if (resultsEndRegex.test(message)) {
				inResults = false;
				testResult = JSON.parse(results.join('').trim());
				finish(null,testResult);
			}
			else if (inResults) {
				results.push(message);
			}
			else {
				log[label](message);
			}
		}

		var tasks = [];

		if (platform_ios && program.target==='device') {
			tasks.push(function(next){
				ioslib.profile.find(tiapp.id,function(err,results){
					if (err) { return next(err); }
					args.unshift(results.developer_name.replace('iPhone Developer: ',''));
					args.unshift('--developer-name');
					args.unshift(results.profiles[0]);
					args.unshift('--pp-uuid');
					args.unshift(results.device_id);
					args.unshift('--device-id');
					next();
				});
			});
		}

		var tilogger;

		tasks.push(function(next){
			var child = spawn('ti',args);
			child.on('error', next);
			child.on('close',function(exitCode){
				if (exitCode!==0) {
					return next("ti build exited with exitCode "+exitCode);
				}
				next();
			});
			// attach platform specific logger
			tilogger = new ioslib.log(tiapp.name,function(label,message){
				// ti will emit some weird symbols as beginning. strip those out
				log[label](message.replace(/^[\s\b:]*/,''));
			});
			tilogger.attach(child);
		});

		tasks.push(function(next){
			if (platform_ios) {
				var name;

				switch (program.target) {
					case 'device':{
						name = 'iphoneos';
						break;
					}
					case 'simulator': {
						name = 'iphonesimulator';
						break;
					}
					default: {
						return next("incorrect target");
					}
				}

				var xcodebuild_dir = path.join(build_dir,'build','iphone','build','Debug-'+name);
				xcodebuild_dir = path.join(xcodebuild_dir,fs.readdirSync(xcodebuild_dir).filter(function(n) { return path.extname(n)=='.app'; } )[0]);

				var config = {
					build_dir: xcodebuild_dir,
					unit: true,
					hide: true,
					logger: logger,
					callback: next
				};

				targetlib = ioslib;

				ioslib[program.target].launch(config);
			}
			else if (platform_android) {
				var name = tiapp.name.charAt(0).toUpperCase()+tiapp.name.substring(1),
					apk = path.join(build_dir,'build','android','bin',name+'.apk');

				var config = {
					apk: apk,
					name: name,
					appid: tiapp.id,
					target: program.target,
					unit: true,
					hide: true,
					logger: logger,
					callback: next
				};
				targetlib = androidlib;

				androidlib[program.target].launch(config);
			}
			else {
				//TODO
			}
		});

		async.series(tasks, finish);
	}

	var specfiles = filelisting(program.recursive,specs,function(f){return /\.js$/.test(f)}),
		tasks = [],
		appjs = path.join(resource_dir,'app.js'),
		iterations = program.count || 1,
		cwd = process.cwd();

	// perform the unzip of the module -- this is currently a regression in 3.3.0 https://jira.appcelerator.org/browse/TIMOB-17144
	tasks.push(function(next){
		if (module_dest && fs.existsSync(module_dest)) {
			process.chdir(build_dir);
			//TODO: fix for windows
			return exec('/usr/bin/unzip -o "'+module_dest+'"', function(){
				process.chdir(cwd);
				next();
			});
		}
		next();
	});

	var code =  'require("ti-mocha");'+
				'\nvar should=require("should");'+
				'\nvar $timer=require("com.appcelerator.timer");\n';

	// load and run each spec file
	specfiles.forEach(function(fn){
		var jscode = fs.readFileSync(fn,'utf8').toString(),
			ast = UglifyJS.parse(jscode);

		// transform each spec file and re-write each test spec to run N times
		// based on the --count value
		function visitor(node, descend) {
			if (node instanceof UglifyJS.AST_Toplevel) {
				return;
			}
			// convert each of our `it` to wrap with an iteration for loop
			if (node instanceof UglifyJS.AST_SimpleStatement) {
				if (node.body.start.type === 'name' &&
					node.body.start.value === 'it' && iterations>1) {
					var testname = node.body.args[0].value;
					if (program.grep && !program.grep.test(testname)) {
						// ignore this branch if not matched
						return new UglifyJS.AST_EmptyStatement();
					}
					var init_ = new UglifyJS.AST_Var({
						definitions: [
							new UglifyJS.AST_VarDef({
								name: new UglifyJS.AST_SymbolVar({name:"$r"}),
								value: new UglifyJS.AST_Number({value:0})
							})
						]
					});
					var cond_ = new UglifyJS.AST_Binary({
						left: new UglifyJS.AST_SymbolRef({name:"$r"}),
						operator:'<',
						right:new UglifyJS.AST_Number({value:iterations})
					});
					var step_ = new UglifyJS.AST_UnaryPostfix({
						operator:'++',
						expression:new UglifyJS.AST_SymbolRef({name:"$r"})

					});
					// create a new node
					var for_ = new UglifyJS.AST_For({
						init: init_,
						condition: cond_,
						step: step_,
						body: node.body
					});
					return for_;
				}
			}
		}

		var tt = new UglifyJS.TreeTransformer(visitor),
			// transform spec file
			new_ast = ast.transform(tt);

		// re-write our JS by adding our wrapping code
		code += new_ast.print_to_string({beautify:true}) + '\n';
	});

	// append the end
	code+=
		'\nvar $results = [];'+
		// add a special mocha reporter that will time each test run using
		// our microsecond timer
		'\nfunction $Reporter(runner){' +
		'\n\tvar started, title;'+
		'\n\trunner.on("suite",function(suite){'+
		'\n\t\ttitle = suite.title;'+
		'\n\t});'+
		'\n\trunner.on("test",function(test){'+
		'\n\t\tstarted = $timer.time();'+
		'\n\t});'+
	 	'\n\trunner.on("fail", function(test, err){'+
	 	'\n\t\ttest.err = err;'+
		'\n\t});'+
		'\n\trunner.on("test end",function(test){'+
		'\n\t\tvar tdiff = $timer.time()-started;'+
		'\n\t\t$results.push({state:test.state,duration:tdiff,suite:title,title:test.title,error:test.err});'+
		'\n\t});'+
		'\n};'+
		'\nmocha.setup({'+
		'\n\treporter: $Reporter,'+
		'\n\tquiet: true'+
		'\n});'+
		// dump the output, which will get interpreted above in the logging code
		'\nvar $runner = mocha.run(function(){'+
		'\n\tvar obj = {results:$results,platform:{},displayCaps:{},build:{}};'+
		'\n\tobj.date = new Date;'+
		'\n\tobj.platform.ostype = Ti.Platform.ostype;'+
		'\n\tobj.platform.name = Ti.Platform.name;'+
		'\n\tobj.platform.osname = Ti.Platform.osname;'+
		'\n\tobj.platform.ostype = Ti.Platform.ostype;'+
		'\n\tobj.platform.version = Ti.Platform.version;'+
		'\n\tobj.platform.address = Ti.Platform.address;'+
		'\n\tobj.platform.macaddress = Ti.Platform.macaddress;'+
		'\n\tobj.platform.architecture = Ti.Platform.architecture;'+
		'\n\tobj.platform.availableMemory = Ti.Platform.availableMemory;'+
		'\n\tobj.platform.manufacturer  = Ti.Platform.manufacturer;'+
		'\n\tobj.platform.model  = Ti.Platform.model ;'+
		'\n\tobj.displayCaps.density = Ti.Platform.displayCaps.density;'+
		'\n\tobj.displayCaps.dpi = Ti.Platform.displayCaps.dpi;'+
		'\n\tobj.displayCaps.platformHeight = Ti.Platform.displayCaps.platformHeight;'+
		'\n\tobj.displayCaps.platformWidth = Ti.Platform.displayCaps.platformWidth;'+
		'\n\tobj.displayCaps.xdpi = Ti.Platform.displayCaps.xdpi;'+
		'\n\tobj.displayCaps.ydpi = Ti.Platform.displayCaps.ydpi;'+
		'\n\tobj.build.date = Ti.buildDate;'+
		'\n\tobj.build.git = Ti.buildHash;'+
		'\n\tobj.build.version = Ti.version;'+
		'\n\tTi.API.info("!TEST_RESULTS_START!");'+
		'\n\tvar str = JSON.stringify(obj,null,3);'+
		'\n\tTi.API.info(str);'+
		'\n\tTi.API.info("!TEST_RESULTS_STOP!");'+
		'\n});';

	fs.writeFileSync(dest_appjs, code, 'utf8');
	tasks.push(runTest);

	function shutdown(err, results) {
		if (err) { die(err); }
		if (program.quiet) {
			console.log(JSON.stringify(results,0,3));
		}
		else {
			log.info(JSON.stringify(results,0,3));
		}
		exit();
	}

	function exit() {
		process.exit(0);
	}

	// run our tests in series and then shutdown
	async.waterfall(tasks,shutdown);
}
